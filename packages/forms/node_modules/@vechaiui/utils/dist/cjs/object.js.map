{"version":3,"sources":["../../src/object.ts"],"names":["omit","object","keys","result","Object","forEach","key","includes","pick","deepmerge","target","source","options","clone","output"],"mappings":";;;;;;;AAAA;;;;AAGO,SAASA,IAAT,CAAiDC,MAAjD,EAA4DC,IAA5D,EAAuE;AAC5E,MAAMC,MAAY,GAAG,EAArB;AAEAC,EAAAA,MAAM,CAACF,IAAP,CAAYD,MAAZ,EAAoBI,OAApB,CAA4B,UAACC,GAAD,EAAS;AACnC,QAAIJ,IAAI,CAACK,QAAL,CAAcD,GAAd,CAAJ,EAA6B;AAC7BH,IAAAA,MAAM,CAACG,GAAD,CAAN,GAAcL,MAAM,CAACK,GAAD,CAApB;AACD,GAHD;AAKA,SAAOH,MAAP;AACD;;AAEM,SAASK,IAAT,CAAiDP,MAAjD,EAA4DC,IAA5D,EAAuE;AAC5E,MAAMC,MAAM,GAAG,EAAf;AAEAD,EAAAA,IAAI,CAACG,OAAL,CAAa,UAACC,GAAD,EAAS;AACpB,QAAIA,GAAG,IAAIL,MAAX,EAAmB;AACjBE,MAAAA,MAAM,CAACG,GAAD,CAAN,GAAcL,MAAM,CAACK,GAAD,CAApB;AACD;AACF,GAJD;AAMA,SAAOH,MAAP;AACD;;AAEM,SAASM,SAAT,CACLC,MADK,EAELC,MAFK,EAGLC,OAHK,EAIL;AAAA,MADAA,OACA;AADAA,IAAAA,OACA,GAD8B;AAAEC,MAAAA,KAAK,EAAE;AAAT,KAC9B;AAAA;;AACA,MAAMC,MAAM,GAAGF,OAAO,CAACC,KAAR,gBAAqBH,MAArB,IAAgCA,MAA/C;;AAEA,MAAI,yBAASA,MAAT,KAAoB,yBAASC,MAAT,CAAxB,EAA0C;AACxCP,IAAAA,MAAM,CAACF,IAAP,CAAYS,MAAZ,EAAoBN,OAApB,CAA4B,UAACC,GAAD,EAAS;AACnC;AACA,UAAIA,GAAG,KAAK,WAAZ,EAAyB;AACvB;AACD;;AAED,UAAI,yBAASK,MAAM,CAACL,GAAD,CAAf,KAAyBA,GAAG,IAAII,MAApC,EAA4C;AAC1C;AACAI,QAAAA,MAAM,CAACR,GAAD,CAAN,GAAcG,SAAS,CAACC,MAAM,CAACJ,GAAD,CAAP,EAAcK,MAAM,CAACL,GAAD,CAApB,EAA2BM,OAA3B,CAAvB;AACD,OAHD,MAGO;AACLE,QAAAA,MAAM,CAACR,GAAD,CAAN,GAAcK,MAAM,CAACL,GAAD,CAApB;AACD;AACF,KAZD;AAaD;;AAED,SAAOQ,MAAP;AACD","sourcesContent":["import { isObject } from \"./assertion\";\nimport type { Dict } from \"./types\";\n\nexport function omit<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result: Dict = {};\n\n  Object.keys(object).forEach((key) => {\n    if (keys.includes(key as K)) return;\n    result[key] = object[key];\n  });\n\n  return result as Omit<T, K>;\n}\n\nexport function pick<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result = {} as { [P in K]: T[P] };\n\n  keys.forEach((key) => {\n    if (key in object) {\n      result[key] = object[key];\n    }\n  });\n\n  return result;\n}\n\nexport function deepmerge<T1, T2>(\n  target: Partial<T1>,\n  source: Partial<T2>,\n  options: { clone: boolean } = { clone: false }\n) {\n  const output = options.clone ? { ...target } : target;\n\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach((key) => {\n      // Avoid prototype pollution\n      if (key === \"__proto__\") {\n        return;\n      }\n\n      if (isObject(source[key]) && key in target) {\n        // Since `output` is a clone of `target` and we have narrowed `target` in this block we can cast to the same type.\n        output[key] = deepmerge(target[key], source[key], options);\n      } else {\n        output[key] = source[key];\n      }\n    });\n  }\n\n  return output;\n}\n"],"file":"object.js"}